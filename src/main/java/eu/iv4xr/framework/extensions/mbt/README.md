# Model-based Testing (MBT)

This package `eu.iv4xr.framework.extensions.mbt` provides an implementation of MBT. Currently the supported test generation approach is an _online_ generation. This means that test-sequences are generated by directly interacting with the System under Test (SUT). This has the benefit that the generator can observe the actual state of the SUT before deciding what the next test-step to generate.

### Related information

The test generation makes use `aplib` agent as executor. `aplib` is a Java library that provides an agent programming framework. Although it is a generic agent framework, its main use case has been for game testing.

* Conceptual explanation of how our online MBT for computer games work: see the paper _Model-based Testing Computer Games: Does It
Work?_, I.S.W.B. Prasetya, in the
21th Workshop on Advances in Model Based Testing (A-MOST) 2025.

* Conceptual explanation on how the agent-based framework `aplib` works: see the paper [_Aplib: Tactical agents for testing computer games_](https://link.springer.com/chapter/10.1007/978-3-030-66534-0_2), by Prasetya, I. S. W. B., Mehdi Dastani, Rui Prada, Tanja EJ Vos, Frank Dignum, and Fitsum Kifetew.
In International Workshop on Engineering Multi-Agent Systems. Cham: Springer International Publishing, 2020.

* The MBT approach is currently provided as a branch of `aplib` called `mbt`. This located at https://github.com/iv4xr-project/aplib/tree/mbt

* The main branch of `aplib`: https://github.com/iv4xr-project/aplib


### Constructing a model

Models are not expressed in the usual Finite State Machine (FSM) way. Instead, predicates are used to specify different kinds of SUT states that we care about.

A model is represented by an instance of the class [`MBTModel`](./src/main/java/eu/iv4xr/framework/extensions/mbt/MBTModel.java). This can be created:

```Java
import eu.iv4xr.framework.extensions.mbt.MBTModel
...
var model = new MBTModel<MyState>("model-name")
```

where `MyState` can in principle be any class representing the state of the SUT (or an interface allowing us to observe the state of the SUT).
**However, since the MBT test generator uses `aplib` agent as the underlying executor**, `MyState` should be an instance of `aplib` agent state. More precisely, it has to be a subclass of [`SimpleState`](./src/main/java/nl/uu/cs/aplib/mainConcepts/SimpleState.java).


Whereas `MyState` represents SUT state, a model also has model-states. These are abstraction representation of actual SUT states.

In our modelling approach, we will have finite number of model-states. As we will see, a model-state is described a predicate. It is added to the model like this:

```Java
model.addState(S1,S2,...)
```

where S1, S2, ... are model-states. A model-state is an instance of the class [`MBTState`](./src/main/java/eu/iv4xr/framework/extensions/mbt/MBTState.java). Internally, it is a conjunction of predicates over `MyState`, as in `p1 ∧ p2 ∧ ...`. So, if e.g. S1 is internally the predicate `p1 ∧ p2`, it represents the set of all instances of `MyState` on which `p1 ∧ p2` holds. Check the code of [`MBTState`](./src/main/java/eu/iv4xr/framework/extensions/mbt/MBTState.java) to figure out how to construct its instances.

An action/transition is added like this:

```Java
model.addAction(A1,A2,...)
```

where A1 and A2 are instances of [`MBTAction`](./src/main/java/eu/iv4xr/framework/extensions/mbt/MBTAction.java). An ac tion _A_ consists of three parts:

  1. a guard
  1. the actual action
  1. a post-condition.

_A_ is only enabled on the current state, if the guard evaluates to true on the current state (more precisely, on the instance of `MyState` representing the current state). During MBT test generation, the generator will only choose an enabled action to execute. The 'actual action' part is meant to interact with the SUT and possibly move the latter to a new state. After executing this, the generator will sample the state and checks whether the post-condition of _A_ holds on the new SUT state. If it holds, the test generation continues. If it does not hold, a violation is recorded.

The actual action of _A_ is perhaps the less obvious one. It can be set up like this:

```Java
var A = new MBTAction<MyState>("action-name")
A.withAction(agent -> ...)
```

it needs a lambda-expression that takes an `aplib` TestAgent as an argument and returns a boolean value. The lambda-expression is meant to trigger some execution of the SUT via the agent. How this is done is up you. If the execution succeeds, the lambda-expression should return _true_, and else _false_.

### Generating tests

The class [`MBTRunner`](./src/main/java/eu/iv4xr/framework/extensions/mbt/MBTRunner.java) implements an online MBT test generator. We create a generator like this:

```Java
var generator = new MBTRunner(model)
```

To run the generator you first need an `aplib` test agent (an instance of the class [`TestAgent`](./src/main/java/eu/iv4xr/framework/mainConcepts/TestAgent.java)). This test agent should be programmed in such a way such that (1) it can control the SUT, and (2) it has access to the SUT state via the agent state.

To run the generator:

```Java
generator.generate(dummy -> ... , N, depth, time)
```

_N_ is the number of test sequences to generate; _depth_ is the maximum length of the sequences; _time_ is the given time budget in ms.  

The lambda-expression is a function that returns an `aplib` agent is connected to the SUT.

The method `generate` returns a list R. Every member r in R represent the result of executing a test sequence. This r is a sequence of action-level results. They can be inspected to check if an action in a test sequence caused a violation.
